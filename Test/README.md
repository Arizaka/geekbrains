# Условие задачи

Используя язык Java необходимо написать метод объединения имеющихся цен с вновь импортированными из внешней системы. 
  
Также необходимо написать unit тесты, для проверки хотя бы некоторых возможных вариантов. 
  
Каждый продаваемый товар, имеет свою цену. Цен у товара может быть несколько, каждая цена имеет свой номер, принадлежность к отделу, период действия и значение в валюте. В базе данных для каждого товара хранится история цен. В один момент времени может действовать только одна цена из цен, с одинаковым номером и отделом. Обычно товар продается по первой цене, вторая, третья и четвертая могут используются для применения скидок (т.е. сработало условие скидки, товар будет продан по цене номер 2). Касса может обслуживать какой-то отдел, тогда она будет использовать при продаже цены указанные для этого отдела. 
  
Правила объединения цен:
  
  Если товар еще не имеет цен, или имеющиеся цены не пересекаются в периодах действия с новыми, то новые цены просто добавляются к товару;
  
  Если имеющаяся цена пересекается в периоде действия с новой ценой, то:
  
* если значения цен одинаковы, период действия имеющейся цены увеличиваетсясогласно периоду новой цены;
* если значения цен отличаются, добавляется новая цена, а период действия старой цены уменьшается согласно периоду новой цены.
Метод в качестве параметров получает коллекцию имеющихся цен, новых цен и должен вернуть коллекцию объединенных цен, для дальнейшего сохранения в БД.

Пример полей класса «цена»:
```sh
long id; // идентификатор в БД

String product_code; // код товара

int number; // номер цены

int depart; // номер отдела

Date begin; // начало действия

Date end; // конец действия

long value; // значение цены в копейках
```
Примеры объединений:

Имеющиеся цены

product_code | number | depart | begin | end | value |
--- | --- | --- | --- |--- |--- |
122856 | 1 | 1 | 01.01.2013 00:00:00 | 31.01.2013 23:59:59 | 11000 |
122856 | 2 | 1 | 10.01.2013 00:00:00 | 10.01.2013 00:00:00 | 99000 |
6654 | 1 | 2 | 01.01.2013 00:00:00 | 31.01.2013 00:00:00 | 5000 |

Новые цены

product_code | number | depart | begin | end | value |
--- | --- | --- | --- |--- |--- |
122856 | 1 | 1 | 20.01.2013 00:00:00 | 20.02.2013 23:59:59 | 11000 |
122856 | 2 | 1 | 15.01.2013 00:00:00 | 25.01.2013 23:59:59 | 92000 |
6654 | 1 | 2 | 12.01.2013 00:00:00 | 13.01.2013 00:00:00 | 4000 |

Результат

product_code | number | depart | begin | end | value |
--- | --- | --- | --- |--- |--- |
122856 | 1 | 1 | 01.01.2013 00:00:00 | 20.02.2013 23:59:59 | 11000 |
122856 | 2 | 1 | 10.01.2013 00:00:00 | 15.01.2013 00:00:00 | 92000 |
122856 | 2 | 1 | 15.01.2013 00:00:00 | 25.01.2013 23:59:59 | 11000 |
6654 | 1 | 2 | 01.01.2013 00:00:00 | 12.01.2013 00:00:00 | 4000 |
6654 | 1 | 2 | 12.01.2013 00:00:00 | 13.01.2013 00:00:00 | 4000 |
6654 | 1 | 2 | 13.01.2013 00:00:00 | 31.01.2013 00:00:00 | 4000 |

# Подход к решению №1

  - Разделение исходной и новой коллекций по департаментам. Итерирование по новым коллекциям
  - Поиск уникальных подколлекций для уникальных наборов number-product_code для новых и старых цен
  - Объединение периодов действия цен
  - Восстановление цен из новой временной шкалы 
  - Слияние последовательно идущих цен с одинаковыми value
  
## Реализация подхода №1

### Разделение исходных коллекций

- Выбираем в исходной и новой коллекциях департаменты в качестве ключей, складываем их в Map<Integer, LinkedList<Price>>, где значения - это цены для департамента. Далее проходим по карте, относящейся к новым данным, если отдела не существует в старых данных (в данном примере это отдел 4), то добавляем весь отдел к результирующим данным. В противном случае проходимся по коллекции LinkedList<Price>, по каждому существующему отделу

![step1](https://github.com/soloyes/geekbrains/blob/master/Test/pictures/step1.png)

### Поиск уникальных наборов number-product_code

- Теперь необходимо найти уникальные наборы number-product_code. В новых данных выбираем первое значение (помним , что на департамент не обращаем внимание, мы внутри цикла по департаментам), и находим подколлекцию продуктов с таким же набором value-number-product_code (newPricesByIDAndNumber). Затем ищем в старых данных данный набор number-product_code, формируя коллекцию таких продуктов (oldPricesByIDAndNumber). Если набора value-number-product_code не существует (oldPricesByIDAndNumber.size = 0), то к результирующим данным добавляем всю подколлекцию по значению number-product_code (result.addAll(newPricesByIDAndNumber)). При этом, при формировании подколлекций, из набора старых данных и новых данных цены удаляются, в целях оптимизации (result.add(p);iterator.remove();).

### Объединение периодов действия

На текущий момент имеется две коллекции. В них находятся цены, у которых number-product_code одинаковы. А значит, мы можем не обращать на них внимание, и оперировать только value, start, end. На текущем шаге алгоритма необходимо создать упорядоченный набор временных отметок, исходя из правила, что start/end любой цены старого набора данных должен быть удалён, если находится между start/end любой цены нового набора данных.

![step2](https://github.com/soloyes/geekbrains/blob/master/Test/pictures/step2.png)

Красным показаны величины, которые не попадут в итоговый набор дат, зелёным - которые попадут.

### Восстановление

Чтобы по набору дат восстановить значения value, и связать интервалы start/stop, воспользуемся слещующей логикой:

- Если 

### Слияние
   
